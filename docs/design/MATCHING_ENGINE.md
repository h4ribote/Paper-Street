# Matching Engine Strict Rules

## 1. 概要 (Overview)
本ドキュメントは、Paper Streetの株式・債券市場における板取引（Order Book Trading）のマッチングエンジンの厳密な挙動ルールを定義します。
金融商品の公正な取引を保証するため、以下のルールは絶対的であり、例外なく適用されます。

## 2. マッチングアルゴリズム (Matching Algorithm)
マッチングエンジンは、**「価格優先・時間優先 (Price-Time Priority)」** の原則に基づいて注文を処理します。

### 2.1. 価格優先 (Price Priority)
*   **買い注文 (Buy Orders)**: 高い価格の注文が優先されます。
*   **売り注文 (Sell Orders)**: 低い価格の注文が優先されます。

### 2.2. 時間優先 (Time Priority)
*   同じ価格の注文同士では、先にサーバーに到達し、注文IDが発行された注文が優先されます。
*   注文の変更（価格変更、数量増額）が行われた場合、時間優先順位はリセットされ、最後尾に移動します。
    *   **数量減額 (Reduce Quantity)** の場合は、元の時間優先順位が維持されます。

## 3. 注文タイプと挙動 (Order Types & Behavior)

### 3.1. 指値注文 (Limit Order)
指定された価格、またはそれより有利な価格でのみ約定します。
*   **Buy Limit**: 指定価格以下で買い付けます。
    *   板に売り注文がある場合（対当する売り気配値 <= 指定価格）、即座に約定します（Taker）。
    *   板に売り注文がない場合、指定価格で板に並びます（Maker）。
*   **Sell Limit**: 指定価格以上で売却します。
    *   板に買い注文がある場合（対当する買い気配値 >= 指定価格）、即座に約定します（Taker）。
    *   板に買い注文がない場合、指定価格で板に並びます（Maker）。

### 3.2. 成行注文 (Market Order)
価格を指定せず、現在の市場で利用可能な最良価格で即座に約定します。
*   **Buy Market**: 板にある売り注文（Ask）に対し、安い順に約定していきます。
*   **Sell Market**: 板にある買い注文（Bid）に対し、高い順に約定していきます。
*   **残余数量の扱い**:
    *   全量が約定した場合：注文完了（FILLED）。
    *   板の注文を食い尽くしても数量が残った場合（Liquidity Exhaustion）：残りの数量は **即座にキャンセル** されます（Partial Fill & Cancel）。成行注文が板に残ることはありません。
*   **保護措置 (Protection)**:
    *   **Price Guard**: 最良気配値から一定割合（例: ±5%）乖離した価格での約定を禁止します。

### 3.3. 逆指値注文 (Stop Order)
市場価格が指定されたトリガー価格（Stop Price）に到達した時点で、注文を発効させます。
*   **Stop Market**: トリガー価格に到達すると、成行注文として発注されます。
*   **Stop Limit**: トリガー価格に到達すると、指値注文として発注されます。
*   **トリガー条件**:
    *   Buy Stop: 最新約定価格（Last Traded Price） >= トリガー価格
    *   Sell Stop: 最新約定価格（Last Traded Price） <= トリガー価格

## 4. 約定ロジック (Execution Logic)

### 4.1. Maker / Taker
*   **Maker**: 板に注文を並べ、流動性を提供した主体。
*   **Taker**: 板にある既存の注文に対し、即座に約定させた主体。
*   **判定**: 注文受領時に即時約定（Immediate Execution）が発生した部分がTaker、板に残った部分がMakerとなります。

### 4.2. 部分約定 (Partial Fills)
*   1つの注文が複数の相手方注文と約定する場合、それぞれの相手方注文に対して個別の約定（Execution）が生成されます。
*   注文ステータスは `PARTIAL` となり、残数量が0になるまで有効です（GTCの場合）。

### 4.3. 自己売買防止 (Self-Trade Prevention)
*   同一ユーザーの買い注文と売り注文がマッチングする場合、新しい注文（Taker側）が即座に拒否（Reject）されます。
*   これにより、意図しないウォッシュトレードや手数料の無駄な支払いを防ぎます。

## 5. データ整合性と演算 (Data Integrity & Math)

### 5.1. 整数演算 (Integer Math)
*   すべての価格と数量は、浮動小数点数（float/double）ではなく、**固定小数点の整数（Decimal/Integer）** として扱われます。
    *   例: $10.50 は `1050` (scale=2) として内部処理されます。
*   これにより、浮動小数点演算特有の丸め誤差（$0.1 + 0.2 = 0.30000000000000004）を完全に排除します。

### 5.2. 通貨ペアと単位
*   **Quote Currency**: 価格は常に決済通貨（例: ARC）の最小単位（整数）で表されます。
*   **Base Asset**: 数量は常に取引対象資産（例: 株式数）の最小単位（整数）で表されます。

## 6. 同時実行制御 (Concurrency Control)

### 6.1. シーケンシャル処理
*   特定の銘柄（Symbol）に対する注文処理は、Redis上のキューを用いて**完全に順序化（Serialized）** されます。
*   同一銘柄に対して同時に複数の注文が到着した場合でも、並列処理は行わず、1つずつ順番にマッチングエンジンに入力されます。これにより、レースコンディション（競合状態）を防ぎ、確定的な結果を保証します。

### 6.2. 楽観的ロックの排除
*   マッチングエンジン内部では、DBへの書き込みを行わず、オンメモリ（Redis）の状態を更新します。
*   約定結果の永続化（MySQLへの書き込み）は非同期で行われますが、マッチングの事実はメモリ上で確定しているため、ロールバックは発生しません。

## 7. エラーハンドリング (Error Handling)

*   **残高不足 (Insufficient Funds/Balance)**:
    *   注文受付時に、必要な資金（Buy）または資産（Sell）のロック（Hold）を行います。
    *   ロックに失敗した場合、注文は即座に拒否（REJECTED）されます。
*   **システムエラー**:
    *   マッチングエンジン内部で予期せぬエラーが発生した場合、該当する注文は「保留」状態となり、管理者にアラートが送信されます。市場全体の停止を防ぐため、当該銘柄のみ取引停止（Halt）となる場合があります。

## 8. 手数料 (Fees)

### 8.1. 約定ごとの徴収 (Collection per Execution)
*   取引手数料は、注文単位ではなく、**約定（Execution）が発生するたびに徴収**されます。
*   例えば、1つの大きな買い指値注文が、複数の小さな売り注文とマッチングして部分約定（Partial Fill）を繰り返す場合、その都度手数料が計算され、差し引かれます。

### 8.2. 端数処理 (Rounding)
*   手数料計算において発生した小数点以下の端数は、**常に切り上げ（Ceiling）** されます。
*   これにより、最低でも1単位（1 cent / 1 satoshi等）の手数料が徴収されることを保証し、極小額取引による手数料回避（Dust Attack）を防ぎます。
